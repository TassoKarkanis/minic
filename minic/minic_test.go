package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/require"
)

func TestEmptyFunction(t *testing.T) {
	runTest(t, "empty-function")
}

func TestReturnOne(t *testing.T) {
	runTest(t, "return-one")
}

func TestAdd(t *testing.T) {
	runTest(t, "add")
}

func TestAddMany(t *testing.T) {
	runTest(t, "add-many")
}

func TestReturnArg(t *testing.T) {
	runTest(t, "return-arg")
}

func TestSub(t *testing.T) {
	runTest(t, "sub")
}

func TestMult(t *testing.T) {
	runTest(t, "mult")
}

func TestDiv(t *testing.T) {
	runTest(t, "div")
}

func TestVar(t *testing.T) {
	runTest(t, "var")
}

func TestVarScope(t *testing.T) {
	runTest(t, "var-scope")
}

func TestUnaryMinus(t *testing.T) {
	runTest(t, "unary-minus")
}

func TestUnaryPlus(t *testing.T) {
	runTest(t, "unary-plus")
}

func TestModulus(t *testing.T) {
	runTest(t, "modulus")
}

func TestEqual(t *testing.T) {
	runTest(t, "equal")
}

func TestNotEqual(t *testing.T) {
	runTest(t, "not-equal")
}

func runTest(t *testing.T, name string) {
	r := testRunner{
		name:       name,
		miniC:      NewMiniC(),
		Assertions: require.New(t),
	}

	r.run()
}

type FileType int

const (
	FileDriverC      FileType = iota // (stored) C file of test driver
	FileDriverObject                 // (generated) C file of test driver (compiled with gcc)
	FileExpectedAsm                  // (stored) expected assembly output
	FileInputC                       // (stored) test input C file
	FileOutputAsm                    // (generated) actual assembly output
	FileOutputGccAsm                 // (generated) assembly output generated by gcc
	FileOutputObject                 // (generated) assembled output file
	FileOutputBin                    // (generated) test binary
	FileOutputGccBin                 // (generated) binary all compiled with gcc
)

var filePostFix = map[FileType]string{
	FileDriverC:      ".driver.c",
	FileDriverObject: ".driver.o",
	FileExpectedAsm:  ".asm",
	FileInputC:       ".c",
	FileOutputAsm:    ".out.asm",
	FileOutputGccAsm: ".out.gcc.asm",
	FileOutputObject: ".o",
	FileOutputBin:    ".out",
	FileOutputGccBin: ".gcc.out",
}

type testRunner struct {
	name  string
	miniC *MiniC
	*require.Assertions
}

func (r *testRunner) run() {
	log.SetLevel(log.DebugLevel)

	r.runGcc()
	r.runMinic() // compile and run with miniC
}

// compile and run with gcc
func (r *testRunner) runGcc() {
	r.assembleGcc()
	r.buildBinGcc()
	r.runTestGcc()
}

func (r *testRunner) runMinic() {
	r.compile()
	r.compareToExpected()
	r.assemble()
	r.buildBin()
	r.runTest()
}

func (r *testRunner) assembleGcc() {
	gccCmd := []string{
		"gcc",
		"-Wall",
		"-c",
		"-S",
		r.getFile(FileInputC),
		"-o",
		r.getFile(FileOutputGccAsm),
	}
	output, err := r.runCommand(gccCmd)
	if err != nil {
		fmt.Print(output)
	}
	r.NoError(err)
}

func (r *testRunner) buildBinGcc() {
	gccCmd := []string{
		"gcc",
		"-Wall",
		r.getFile(FileInputC),
		r.getFile(FileDriverC),
		"-o",
		r.getFile(FileOutputGccBin),
	}
	output, err := r.runCommand(gccCmd)
	fmt.Print(output)
	r.NoError(err)
}

func (r *testRunner) runTestGcc() {
	cmdLine := []string{r.getFile(FileOutputGccBin)}
	output, err := r.runCommand(cmdLine)
	fmt.Print(output)
	r.NoError(err)
}

func (r *testRunner) compile() {
	// compile to assembly
	err := r.miniC.CompileFile(r.getFile(FileInputC), r.getFile(FileOutputAsm))
	r.NoError(err)
}

func (r *testRunner) compareToExpected() {
	// read the expected file
	expectedFile := r.getFile(FileExpectedAsm)
	expected, err := os.ReadFile(expectedFile)
	r.NoError(err)

	// compare the generated output with the expected
	actualFile := r.getFile(FileOutputAsm)
	actual, err := os.ReadFile(actualFile)
	r.NoError(err)

	if string(actual) != string(expected) {
		// diff the two files
		cmdLine := []string{"diff", "-c", expectedFile, actualFile}
		output, _ := r.runCommand(cmdLine)
		fmt.Println(output)
		r.Fail("result not as expected")
	}
}

func (r *testRunner) assemble() {
	err := r.miniC.AssembleFile(r.getFile(FileOutputAsm), r.getFile(FileOutputObject))
	r.NoError(err)
}

func (r *testRunner) buildBin() {
	// compile the driver with gcc
	gccCmd := []string{
		"gcc",
		"-c",
		r.getFile(FileDriverC),
		"-o",
		r.getFile(FileDriverObject),
	}
	output, err := r.runCommand(gccCmd)
	if err != nil {
		fmt.Print(output)
	}
	r.NoError(err)

	// link with minic
	modules := []string{
		r.getFile(FileDriverObject),
		r.getFile(FileOutputObject),
	}
	err = r.miniC.Link(modules, r.getFile(FileOutputBin))
	r.NoError(err)
}

func (r *testRunner) runTest() {
	cmdLine := []string{r.getFile(FileOutputBin)}
	output, err := r.runCommand(cmdLine)
	fmt.Print(output)
	r.NoError(err)
}

func (r *testRunner) runCommand(cmdLine []string) (string, error) {
	cmd := exec.Command(cmdLine[0], cmdLine[1:]...)
	stdout := &bytes.Buffer{}
	stderr := &bytes.Buffer{}
	cmd.Stdout = stdout
	cmd.Stderr = stderr
	err := cmd.Run()
	output := stdout.String() + stderr.String()
	return output, err
}

func (r *testRunner) getFile(fileType FileType) string {
	dir := "testdata"
	return filepath.Join(dir, r.name+filePostFix[fileType])
}
